using Microsoft.AspNetCore.Mvc;
using backend.Models;
using backend.Services;
using System.Collections.Generic;
using System.Threading.Tasks;
using System.Linq;
using System.Text;
using Microsoft.Extensions.Logging;

namespace backend.Controllers
{
    [Route("api/[controller]")]
    [ApiController]
    public class ProblemsController : ControllerBase
    {
        private readonly IGrokService _grokService;
        private readonly ILogger<ProblemsController> _logger;

        // Simulated problem database (in reality, Grok would generate these)
        private static readonly List<Problem> Problems = new List<Problem>
        {
            new Problem
            {
                Id = 1,
                SourceLanguage = "TypeScript",
                TargetLanguage = "C#",
                SourceCode = @"function add(a: number, b: number): number { 
    return a + b; 
}",
                ExpectedTargetCode = @"public int Add(int a, int b) { 
    return a + b; 
}"
            },
            new Problem
            {
                Id = 2,
                SourceLanguage = "C#",
                TargetLanguage = "TypeScript",
                SourceCode = @"public string Greet(string name) { 
    return $""Hello, {name}""; 
}",
                ExpectedTargetCode = @"function greet(name: string): string { 
    return `Hello, ${name}`; 
}"
            }
        };

        public ProblemsController(IGrokService grokService, ILogger<ProblemsController> logger)
        {
            _grokService = grokService;
            _logger = logger;
        }

        [HttpGet]
        public ActionResult<Problem> GetProblem([FromQuery] string sourceLang, [FromQuery] string targetLang)
        {
            Console.WriteLine($"GetProblem request received: sourceLang={sourceLang}, targetLang={targetLang}");
            
            // Validate input parameters
            if (string.IsNullOrEmpty(sourceLang) || string.IsNullOrEmpty(targetLang))
            {
                Console.WriteLine("Bad request: sourceLang or targetLang is missing");
                return BadRequest("Source language and target language must be provided");
            }
            
            var problem = Problems.Find(p => p.SourceLanguage == sourceLang && p.TargetLanguage == targetLang);
            
            if (problem == null)
            {
                Console.WriteLine($"Problem not found for {sourceLang} to {targetLang}");
                
                // List available problems for debugging
                var availableProblems = Problems.Select(p => $"{p.SourceLanguage} to {p.TargetLanguage}").ToList();
                Console.WriteLine($"Available problems: {string.Join(", ", availableProblems)}");
                
                return NotFound($"No problem found for translating from {sourceLang} to {targetLang}");
            }
            
            Console.WriteLine($"Problem found: ID={problem.Id}");
            return Ok(problem);
        }

        [HttpPost("check")]
        public async Task<ActionResult<string>> CheckAnswer([FromBody] Submission submission)
        {
            // Log received data
            _logger.LogInformation($"Received submission: SourceLang={submission?.SourceLanguage}, TargetLang={submission?.TargetLanguage}");
            _logger.LogInformation($"UserCode length: {submission?.UserCode?.Length ?? 0}");
            _logger.LogInformation($"OriginalSourceCode length: {submission?.OriginalSourceCode?.Length ?? 0}");
            
            if (submission == null)
            {
                return BadRequest(new { message = "Submission data is null" });
            }

            if (string.IsNullOrEmpty(submission.UserCode))
            {
                return BadRequest(new { message = "User code is required" });
            }
            
            if (string.IsNullOrEmpty(submission.OriginalSourceCode))
            {
                return BadRequest(new { message = "Original source code is required" });
            }
            
            if (string.IsNullOrEmpty(submission.SourceLanguage) || string.IsNullOrEmpty(submission.TargetLanguage))
            {
                return BadRequest(new { message = "Source and target languages are required" });
            }

            // First check if the problem exists in our static list
            var problem = Problems.Find(p => 
                p.SourceLanguage == submission.SourceLanguage && 
                p.TargetLanguage == submission.TargetLanguage && 
                p.SourceCode == submission.OriginalSourceCode);
            
            // If problem not found in static list and it was generated by Grok API,
            // create a temporary problem object just for evaluation
            if (problem == null)
            {
                _logger.LogInformation("Problem not found in static list. Creating temporary problem for evaluation.");
                // Create a temporary problem object for checking
                problem = new Problem
                {
                    Id = 0, // Temporary ID
                    SourceLanguage = submission.SourceLanguage,
                    TargetLanguage = submission.TargetLanguage,
                    SourceCode = submission.OriginalSourceCode,
                    // We don't have the expected target code, will rely solely on Grok API for validation
                };
            }

            try
            {
                // Use our service to evaluate the code translation
                _logger.LogInformation("Sending to Grok service for validation");
                bool isCorrect = await _grokService.IsCodeTranslationCorrect(
                    problem.SourceCode,
                    submission.UserCode, 
                    submission.SourceLanguage, 
                    submission.TargetLanguage
                );
                _logger.LogInformation($"Grok validation result: {isCorrect}");

                // For a more lenient evaluation, also consider the expected solution if we have it
                if (!isCorrect && !string.IsNullOrEmpty(problem.ExpectedTargetCode))
                {
                    // Direct comparison with the expected solution as a fallback
                    bool matchesExpected = string.Equals(
                        problem.ExpectedTargetCode.Trim(),
                        submission.UserCode.Trim(),
                        StringComparison.OrdinalIgnoreCase
                    );
                    
                    if (matchesExpected)
                    {
                        isCorrect = true;
                        _logger.LogInformation("Solution matches expected answer exactly.");
                    }
                }

                var feedback = isCorrect 
                    ? "Correct! Your translation matches the expected solution." 
                    : "Incorrect. Your translation doesn't match the expected solution. Please try again.";

                return Ok(new { message = feedback, isCorrect = isCorrect });
            }
            catch (Exception ex)
            {
                _logger.LogError($"Error checking answer: {ex.Message}");
                _logger.LogError($"Stack trace: {ex.StackTrace}");
                
                // Add API key information (masked for security)
                string apiKey = _grokService.GetApiKeyInfo();
                _logger.LogInformation($"Using API key: {apiKey}");
                
                // Fallback local validation if Grok API fails
                string note = $"API Error: {ex.Message}. Falling back to local validation.";
                
                // Perform basic comparison as fallback
                bool fallbackValid = false;
                try 
                {
                    fallbackValid = !string.IsNullOrEmpty(problem.ExpectedTargetCode) && 
                        string.Equals(problem.ExpectedTargetCode.Trim(), submission.UserCode.Trim(), 
                        StringComparison.OrdinalIgnoreCase);
                        
                    _logger.LogInformation($"Fallback validation result: {fallbackValid}");
                    
                    var simplifiedUserCode = NormalizeCode(submission.UserCode);
                    var simplifiedExpectedCode = !string.IsNullOrEmpty(problem.ExpectedTargetCode) 
                        ? NormalizeCode(problem.ExpectedTargetCode) 
                        : string.Empty;
                        
                    if (!fallbackValid && !string.IsNullOrEmpty(simplifiedExpectedCode))
                    {
                        fallbackValid = simplifiedUserCode.Equals(simplifiedExpectedCode, StringComparison.OrdinalIgnoreCase);
                        _logger.LogInformation($"Simplified validation result: {fallbackValid}");
                    }
                }
                catch (Exception normEx)
                {
                    _logger.LogError($"Error in fallback validation: {normEx.Message}");
                }
                
                var fallbackMessage = fallbackValid 
                    ? "Correct! Your solution passes the validation." 
                    : "Incorrect. Please review your solution and try again.";
                    
                return Ok(new { message = fallbackMessage, isCorrect = fallbackValid, note = note });
            }
        }

        // Helper method to normalize code for comparison
        private string NormalizeCode(string code)
        {
            if (string.IsNullOrEmpty(code)) return string.Empty;
            
            // Remove whitespace, comments, and make lowercase for more forgiving comparison
            var simplified = System.Text.RegularExpressions.Regex.Replace(code, @"\s+", ""); // Remove whitespace
            simplified = System.Text.RegularExpressions.Regex.Replace(simplified, @"//.*", ""); // Remove single-line comments
            simplified = System.Text.RegularExpressions.Regex.Replace(simplified, @"/\*.*?\*/", "", System.Text.RegularExpressions.RegexOptions.Singleline); // Remove multi-line comments
            return simplified.ToLowerInvariant();
        }

        [HttpGet("health")]
        public ActionResult<object> HealthCheck()
        {
            Console.WriteLine("Health check requested");
            return Ok(new { status = "ok", message = "API is running" });
        }

        [HttpGet("random")]
        public async Task<ActionResult<Problem>> GetRandomProblem([FromQuery] string sourceLang, [FromQuery] string targetLang)
        {
            _logger.LogInformation($"Generating random problem from {sourceLang} to {targetLang}");
            
            if (string.IsNullOrEmpty(sourceLang) || string.IsNullOrEmpty(targetLang))
            {
                return BadRequest("Source language and target language are required");
            }
            
            try
            {
                var problem = await _grokService.GenerateRandomQuestion(sourceLang, targetLang);
                return Ok(problem);
            }
            catch (Exception ex)
            {
                _logger.LogError($"Error generating random problem: {ex.Message}");
                return StatusCode(500, new { message = "Error generating question", error = ex.Message });
            }
        }

        [HttpGet("hint")]
        public async Task<ActionResult<string>> GetHint([FromQuery] string sourceCode, [FromQuery] string targetLang)
        {
            _logger.LogInformation($"Getting hint for translation to {targetLang}");
            
            if (string.IsNullOrEmpty(sourceCode) || string.IsNullOrEmpty(targetLang))
            {
                return BadRequest("Source code and target language are required");
            }
            
            try
            {
                var hint = await _grokService.GetHint(sourceCode, targetLang);
                return Ok(new { hint });
            }
            catch (Exception ex)
            {
                _logger.LogError($"Error getting hint: {ex.Message}");
                return StatusCode(500, new { message = "Error generating hint", error = ex.Message });
            }
        }

        [HttpGet("explain")]
        public async Task<ActionResult<string>> GetExplanation(
            [FromQuery] string sourceCode, 
            [FromQuery] string targetCode, 
            [FromQuery] string sourceLang, 
            [FromQuery] string targetLang)
        {
            _logger.LogInformation($"Getting explanation for {sourceLang} to {targetLang} translation");
            
            if (string.IsNullOrEmpty(sourceCode) || string.IsNullOrEmpty(targetCode))
            {
                return BadRequest(new { message = "Source code and target code are required" });
            }
            
            if (string.IsNullOrEmpty(sourceLang) || string.IsNullOrEmpty(targetLang))
            {
                return BadRequest(new { message = "Source language and target language are required" });
            }
            
            try
            {
                var explanation = await _grokService.GetSolutionExplanation(sourceCode, targetCode, sourceLang, targetLang);
                return Ok(new { explanation });
            }
            catch (Exception ex)
            {
                _logger.LogError($"Error generating explanation: {ex.Message}");
                return StatusCode(500, new { message = "Error generating explanation", error = ex.Message });
            }
        }
    }
}